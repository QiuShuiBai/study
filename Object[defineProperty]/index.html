<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script src="./script1.js"></script>

  <!-- <script>
    // 新猜想，上面script 中是先继承后给子元素赋值
    // 现在是先给子元素赋值，再改变子元素的 __proto__

    const son = {
      name: 'son'
    }

    const father = {}

    Object.defineProperty(father, 'name', {
      get() {
          console.log('get')
          return this._name
        },
        set(nVal) {
          console.log('set')
          this._name = nVal
        }
    })
    Object.defineProperty(father, 'age', {
      get() {
          console.log('get')
          return this._age
        },
        set(nVal) {
          console.log('set')
          this._age = nVal
        }
    })
    console.clear()
    father.name = 'father' // 'set'
    father.age = 40 // 'set'
    father.canAskFather = true

    son.__proto__ = father
    console.log(son.canAskFather) // true 表明能通过原型链访问到 father

    console.log(son.name) // 'son' 不触发
    son.name = 'newSon' // 不触发
    son.age = 18 // 'set'
    console.log(son.age) // 'get' 18
  </script> -->

  <!-- <script>
    const obj = {}

    Object.defineProperty(obj, 'num', {
      get() {
        console.log('get')
        return this._num
      },
      set(nVal) {
        console.log('set')
        this._num = nVal
      }
    })

    obj.num = 0 // set

    const newObj = Object.create(obj)

    Object.defineProperty(newObj, 'num', {
      get() {
        console.log('get1')
        return this._num
      },
      set(nVal) {
        console.log('set1')
        this._num = nVal
      }
    })

    console.log(newObj.__proto__.num)
    newObj.__proto__.num = 2
    console.log(newObj.__proto__.num)
    console.clear()    
    console.log(newObj)
  </script> -->
</body>
</html>